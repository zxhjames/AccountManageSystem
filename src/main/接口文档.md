注：由于还没进行前后端联调，接口的交互方式和异常设置不是最终版

## 获取可用的接口

- 地址  GET  /get-apis
- 说明：目前是返回一个静态的列表，里边装有可以访问并进行报表处理的api，前端可以根据列表，让用户选择一个想要进行报表处理的地址，并进而跳转到报表设计的页面进行下一步的操作。
- 请求结果及状态码：

成功：

状态码 200

```json
{ 
	'code': 200, 
	'status': 'OK', 
	'data': [
  	'http://www.baidu.com',
    'http://hdu.edu.cn'
  ]
}
```

失败： 

状态码 404  原因：当前没有可用的接口，也就是获取到的接口数为0

```json
{
  'code': 404,
  'status': '没有可用的数据'
}
```

状态码 500  原因：后端请求这些接口数据的时候出了问题，当前无法获得到数据

```json
{
  'code': 500,
  'status': '当前请求的服务不可用'
}
```



---



## 获取接口的元数据

- 地址  POST  /get-metadata
- 说明：获取一个接口的实际数据，然后筛选实际数据，只保留实际数据的字段名，作为一个列表返回。这些字段名用于指明表格中的数据填充处。请求的json文件中应该只有一条地址（如下）。返回数据中 count 为字段的总数。
- 请求格式：application/json

```json
{
  'url': 'http://www.baidu.com'
}
```

- 请求结果及状态码：

成功：

 状态码 200

```json
{
	'code': 200,
  'status': 'OK',
  'count': 5,
  'data': ['name', 'id', 'score', 'address', 'phone_number']
 }
```

失败： 

状态码  500  原因：数据接口提供的数据不规范（也有可能是请求的接口中没有数据），无法解析，应该联系管理员

```json
{
  'code': 500,
  'status': '当前请求的接口数据格式不符合规范，因此暂不提供'
}
```

状态码  500  原因：后端请求这些接口数据的时候出了问题，当前无法获得到数据

```json
{  
	'code': 500,  
  'status': '当前请求的服务不可用'
}
```

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{  
  'code': 403,  
  'status': '请求数据构造有误'
}
```

状态码  404  原因：这一步选择的数据源，不存在任何数据，因此不允许依此建立表格

```json
{
  'code': 404,
  'status': '请求数据源中不存在任何数据，不允许创建表格'
}
```



---



## 上传格式信息，并生成excel文件

- 地址  POST  /generator
- 说明：上传在前端表格组件中收集到的格式信息（格式如下，本文最后会详细说明，格式文件的具体每个字段的含义参考本文的**附录**），其中 api 为请求的接口（后端需要在这里获取数据），name 为生成的excel表格的名字。后端根据这个信息去构造excel表格，响应并不会直接返回可下载文件，而是重定向到另一个接口（下载接口，会在后边的接口说明中出现），在那边的接口，会通过传参对本地下载文件进行定位并返回。
- 请求格式：application/json

```json
{
	'api': 'http://localhost:5001/data',
  'name': '第二次测试',
  'data': [
    {
			'merge_or_not': 'B2:C3',
			'is_column': False,
			'text': 'title',
			'bold': True,
			'size': 30,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'B4',
			'is_column': False,
			'text': 'rowkey',
			'bold': False,
			'size': 10,
			'H_align': 0,
			'V_align': 0,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'C4:E4',
			'is_column': False,
			'text': 'name',
			'bold': False,
			'size': 10,
			'H_align': 2,
			'V_align': 2,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'B5',
			'is_column': True,
			'text': 'rowkey',
			'bold': False,
			'size': 10,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'C5:D5',
			'is_column': True,
			'text': 'name',
			'bold': True,
			'size': 10,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 3, 4]
		}, 
    {
			'merge_or_not': 'D11',
			'is_column': False,
			'text': 'sum',
			'bold': False,
			'size': 10,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 2, 3, 4]
		}
  ]  
}
```

- 请求结果及状态码：

成功：

状态码  302  可获取到重定向的地址（该响应没有设计对应的信息）

失败：

状态码  500  原因：后端请求这些接口数据的时候出了问题，当前无法获得到数据

```json
{  
	'code': 500,  
  'status': '当前请求的服务不可用'
}
```

状态码  403  原因：当前请求中的name字段中的存在不符合常规的符号，会影响服务器端文件的生成，由于通信的成本较大，建议在前端进行检查

```json
{
  'code': 403,
  'status': '文件的名字含有非法符号，建议使用汉字和英文字母'
}
```

状态码  500  原因：后端hash过程中出错，一般来讲这个错误是不会出现的，如果出现联系管理员

```json
{  
	'code': 500,  
  'status': '哈希过程出现错误'
}
```

状态码  500  原因：数据插入失败，如果出现请联系管理员

```json
{
  'code': 500,  
  'status': '文件数据插入失败，已回滚'
}
```

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{  
  'code': 403,  
  'status': '请求数据构造有误'
}
```

状态码  403  原因：上传的 json 数据的格式字段为空，不能构造一个空的表格

```json
{  
  'code': 403,  
  'status': '不能构造一个空的表格'
}
```







---



## 下载文件

- 地址  GET  /download/<hash>
- 说明：作为下载服务器端文件的统一入口，参数 hash 为文件信息通过SHA256生成的唯一值，存储在服务器中，作为查询文件信息的索引，相当于接口的明文信息加密。成功后返回一个xlsx格式文件。
- 请求结果及状态码：

成功：

暂时未知

失败：

状态码  404  原因：根据当前 hash 值，未在数据库中查询到对应的文件，故无法返回可下载文件

```json
{
  'code': 404,
  'status': '没有找到对应的文件'
}
```



---



## 不设条件查询以及分页显示

- 地址  POST  /excel-list
- 说明：请求访问数据库中的所有表格信息。带有分页参数（第几页和每页数据个数，默认为第一页和每页十个，第一页为起始页）。目前还没涉及到访问权限（或者说每个人的访问边界的设计）。另外注意，所有查询（这个接口和下个接口）返回的数据都是按照生成时间从新到旧的顺序返回的。
- 请求格式：application/json

```json
{
  'page_num': 2,
  'per_page': 3
}
```

- 请求结果及状态码

成功：

状态码  200  注意这里三条数据的 hash 是相同，因为这是随便编的数据，data中的元素个数和 per_page 是对应的

还需要注意的是，返回给前端的数据，不是数据库中所有列的数据，只选了一些有用的

如果 total_page 为0的话，则说明没有任何数据可以返回。data也是None

```json
{
	'code': 200,
  'status': 'OK',
  'data': [
    {
    	'name': '测试1',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api1',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    },
    {
    	'name': '测试2',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api2',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    },
    {
    	'name': '测试3',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api3',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    }
  ],
  'page_num': 1,
  'per_page': 3,
  'total_page': 4
}
```

失败：

状态码  403  原因：分页参数中的每页显示个数不能为0（第几页不需要判断，前端会处理）

```json
{
  'code': 403,
  'status': '分页参数有误'
}
```

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{  
  'code': 403,  
  'status': '请求数据构造有误'
}
```



---



## 根据文件名字或者创作者进行模糊查询

- 地址  POST  /keyword-search
- 说明：提供对前端搜索框关键词搜索的支持。关键词会在后端对文件名字和创建者（创建者现在还没设计）进行模糊查询，同时返回的查询数据也遵循着分页的特性。关键词默认为空，但是这样就和上一个接口没区别了（所以这里最好前端设计一下，如果搜索框中为空就不允许查询，省的白费力气）
- 请求格式：application/json

```json
{
  'page_num': 2,
  'per_page': 3,
  'key_word': '测试'
}
```

- 请求结果及状态码：

成功：

状态码  200  这里请求的结果和上个接口的结果格式是一样的

```json
{
	'code': 200,
  'status': 'OK',
  'data': [
    {
    	'name': '测试1',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api1',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    },
    {
    	'name': '测试2',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api2',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    },
    {
    	'name': '测试3',
      'creater': 'JH',
      'timestamp': '2020-03-02-16:41:03.235816',
      'source': 'api3',
      'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
    }
  ],
  'page_num': 1,
  'per_page': 3,
  'total_page': 4
}
```

失败：

状态码  403  原因：分页参数中的每页显示个数不能为0（第几页不需要判断，前端会处理）

```json
{
  'code': 403,
  'status': '分页参数有误'
}
```

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{  
  'code': 403,  
  'status': '请求数据构造有误'
}
```

状态码  403  原因：查询的关键词不能为空，虽然也可以做成空的时候查询所有数据，但是这里先把异常给出来

```json
{
  'code': 403,
  'status': '查询关键词不允许为空'
}
```





---



## 删除一条数据，并删除对应的本地文件

- 地址  POST  /delete
- 说明：删除一条数据库中的文件记录以及其对应在本地存放的表格文件。
- 请求格式：application/json

```json
{
  'name': '测试',
  'timestamp': '2020-03-02-16:41:03.235816'
}
```

- 请求结果及状态码

成功：

状态码  200

```json
{
	'code': 200,
  'status': 'OK'
}
```

失败：

状态码  500  原因：数据库删除数据失败，并回滚（也有可能是在数据库中没有查询出来对应的数据可删）

```json
{
  'code': 500,
  'status': '数据库中的文件数据删除失败，已回滚'
}
```

状态码  500  原因：服务器本地表格文件不存在，所以删除失败（本地文件删除失败要和数据库删除区分开来）

```json
{
  'code': 500,
  'status': '本地文件删除失败'
}
```

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{
  'code': 403,
  'status': '请求数据构造有误'
}
```



---



## 重新下载接口

- 地址  POST  /re-download
- 说明：进行本地文件重新下载的接口，会重定向到上边介绍的下载的接口，参数还是使用hash值
- 请求格式：application/json

```json
{
  'hash': '1ba8f1e94d31f63e9c83f78c6d360a9e98495f748719108411ef29e9d40dd58b'
}
```

- 请求结果及状态码

成功：

状态码  302  可获取到重定向的地址（该响应没有设计对应的信息）

失败：

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{
  'code': 403,
  'status': '请求数据构造有误'
}
```



---



## 获取文件保存的格式信息

- 地址  POST  /format-file
- 说明：根据文件名字和时间戳获取数据库中对应文件的格式文件信息。这个信息是在第一次创建文件时保存下来的，舍去了填充数据之外，其他的单元格信息都有保留。前端可以根据保存的格式文件重新创建一个新的文件，并加载对应的格式信息（相当于模板的功能）
- 请求格式：application/json

```json
{
  'name': '测试',
  'timestamp': '2020-03-02-16:41:03.235816'
}
```

- 请求结果及状态码

成功：

状态码  200

```json
{
	'code': 200,
  'status': 'OK',
  'data': [
    {
			'merge_or_not': 'B2:C3',
			'is_column': False,
			'text': 'title',
			'bold': True,
			'size': 30,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'B4',
			'is_column': False,
			'text': 'rowkey',
			'bold': False,
			'size': 10,
			'H_align': 0,
			'V_align': 0,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'C4:E4',
			'is_column': False,
			'text': 'name',
			'bold': False,
			'size': 10,
			'H_align': 2,
			'V_align': 2,
			'border': [1, 2, 3, 4]
		}, 
    {
			'merge_or_not': 'D11',
			'is_column': False,
			'text': 'sum',
			'bold': False,
			'size': 10,
			'H_align': 1,
			'V_align': 1,
			'border': [1, 2, 3, 4]
		}
  ]
}
```

失败：

状态码  403  原因：请求数据构造有误，请检查请求中的 json 文件

```json
{  
	'code': 403,  
  'status': '请求数据构造有误'
}
```

状态码  404  原因：没有在数据库中找到对应的记录，理论上来说对于这个接口不太可能发生这种异常

```json
{
  'code': 404,
  'status': '未能找到对应的格式文件'
}
```



---



## 附录

#### 格式文件中每个字段的说明：

##### merge_or_not：判断是否是合并的单元格。这里有两种情况：

- 如果是，只需要单元格左上和右下的坐标，例如 "A2:D4"（代表这两个单元格所连接的合并区域）
- 如果不是，则只会出现一个坐标，且不会出现 ":"

所以对于单元格是否是合并的，只需判断坐标中是否含有符号 ":"

##### Is_column：判断是否是填充数据，这里也分两种情况：

- False，说明不是填充数据而是普通数据，那么对应的text中的文本内容应该是直接填充到表格当中的
- True，说明是填充数据，这里也分两种情况：第一种，text是"\$-\$"这种一般不会出现的符号，代表此处是时间填充数据，会在后台填充时间而不是内容。第二种，text是一个字符串（大多数情况），那么它代表的是当前请求数据源中的某个字段，在后台需要从上至下（因为只支持数据进行纵向排列），分别对每个单元格进行数据的填充（另外需要注意的是，为了因为是按列填充的数据，为了保证每一行对应的是同一实体的数据，单元格在设置为填充时，不允许出现合并的格式）

##### Text：文本内容：字符串形式，具体用法参考前两个字段

##### Bold：是否是粗体：

- True，加粗
- False，不加粗

##### Size：字体大小：用数字表示，默认为11，建议范围在1到30

##### H_align：水平对齐，0，1，2分别代表居左，居中，居右

##### V_align：垂直对齐，0，1，2分别代表居上，居中，居下

##### Border：代表单元格边框，使用时请使用数组，填充1，2，3，4四种数字，具体格式如下

- 单元格表框有四种，上下左右，所以需要一个数组
- 1代表上边框，2代表下边框，3代表左边框，4代表右边框
- 例如，上，左，右边框为 [1,3,4]
- 对于单元格之间重复的边框，只要有一方是设置单元格，则输出为有单元框

#### 前端表格组件目前需要实现的功能（基于开源的x-spreadsheet）

- 合并单元格（已有，需要轻微改动）
- 字体加粗（已有）
- 字体大小（已有，需要轻微改动）
- 六个方位的对齐（已有）
- 单元框（已有，需要简化一下）
- 复制剪切删除（已有，需要轻微改动）
- 格式刷，消除格式（已有）
- 撤销，撤回（已有）
- 增加，删除，一行或一列（已有）
- 读取格式文件，显示在屏幕上（没有）
- 根据单元格信息生成格式文件传递给后端（没有）
- 一个另外的前端页面，进行历史数据的展示（没有）

除此之外，其余的功能需要去掉

